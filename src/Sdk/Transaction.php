<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Sdk;

use Proximax\API\TransactionRoutesApi;
use Proximax\Model\TransactionDTO;
use Proximax\Model\TransactionStatusDTO;
use Proximax\ApiClient;
use Base32\Base32;
use Proximax\Model\MosaicDTO;
use Proximax\Model\TransactionInfo;
use Proximax\Model\Address;
use Proximax\Model\PublicAccount;
use Proximax\Model\Message;
use Proximax\Model\AbstractTransaction;
use Proximax\Model\Account;
use Proximax\Model\TransactionType;
use Proximax\Model\TransferTransactionDTO;
use Proximax\Model\HashLockTransactionDTO;
use Proximax\Model\AggregateTransactionDTO;
use Proximax\Model\CosignatureDTO;
use Proximax\Model\TransactionMetaDTO;
use Proximax\Model\UInt64DTO;
use Proximax\Model\MessageDTO;
use Proximax\Model\MosaicDefinitionTransactionDTO;
use Proximax\Model\MosaicSupplyChangeTransactionDTO;
use Proximax\Model\RegisterNamespaceTransactionDTO;
use Proximax\Model\AddressAliasTransactionDTO;
use Proximax\Model\MosaicAliasTransactionDTO;
use Proximax\Model\ModifyMultisigAccountTransactionDTO;
use Proximax\Model\AccountPropertiesTransactionDTO;
use Proximax\Model\SecretLockTransactionDTO;
use Proximax\Model\SecretProofTransactionDTO;
use Proximax\Model\AccountLinkTransactionDTO;
use Proximax\Model\EmbeddedTransactionMetaDTO;
use Proximax\Model\EmbeddedHashLockTransactionDTO;
use Proximax\Model\EmbeddedTransferTransactionDTO;
use Proximax\Model\EmbeddedMosaicDefinitionTransactionDTO;
use Proximax\Model\EmbeddedMosaicSupplyChangeTransactionDTO;
use Proximax\Model\EmbeddedRegisterNamespaceTransactionDTO;
use Proximax\Model\EmbeddedAddressAliasTransactionDTO;
use Proximax\Model\EmbeddedMosaicAliasTransactionDTO;
use Proximax\Model\EmbeddedModifyMultisigAccountTransactionDTO;
use Proximax\Model\EmbeddedAccountPropertiesTransactionDTO;
use Proximax\Model\EmbeddedSecretLockTransactionDTO;
use Proximax\Model\EmbeddedSecretProofTransactionDTO;
use Proximax\Model\EmbeddedAccountLinkTransactionDTO;
use Proximax\Model\CosignatoryModificationDTO;
use Proximax\Model\AccountPropertiesModificationDTO;
use Proximax\Model\TransactionInfoDTO;
use Proximax\Model\EmbeddedTransactionInfoDTO;
use Proximax\Model\MosaicPropertyDTO;
use Proximax\Model\TransactionSearchDTO;
use Proximax\Model\PaginationTransactionsDTO;


/**
 * Transaction class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Transaction{

    /**
     *
     * @param config $config
     *
     * @param String $transId
     * 
     * @return TransactionInfoDTO
     */
    public function GetTransaction($config, $transId){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->getTransaction($transId);
        
        if ($data[1] == 200){ // successfull
            return $this->formatData($networkType, $data[0]);
        }
        else return null;
    }

    /**
     *
     * @param config $config
     *
     * @param String $transId Array of transaction ids or hashes
     * 
     * @return TransactionDTO array
     */
    public function GetTransactions($config, $transIds, $groupType){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->getTransactions($transIds, $groupType);
        $arr_trans = array();
        if ($data[1] == 200){ // successfull
            for($i=0;$i<count($data[0]);$i++){
                $transaction = $this->formatData($networkType, $data[0][$i]);
                $arr_trans[$i] = $transaction;
            }
        }
        return $arr_trans;
    }

    /**
     *
     * @param config $config
     *
     * @param String $hash
     * 
     * @return TransactionStatusDTO
     */
    public function GetTransactionStatus($config, $hash){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->getTransactionStatus($hash);
        
        if ($data[1] == 200){ // successfull
            $transactionStatus = $this->formatDataStatus($data[0]);
        }
        else $transactionStatus = null;

        return new TransactionStatusDTO($transactionStatus);
    }

    /**
     *
     * @param config $config
     *
     * @param String $hash array
     * 
     * @return TransactionStatusDTO
     */
    public function GetTransactionsStatuses($config, $hashes){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->getTransactionsStatuses($hashes);
        $arr_statuses = array();
        if ($data[1] == 200){ // successfull
            for($i=0;$i<count($data[0]);$i++){
                $transactionStatus = $this->formatDataStatus($data[0][$i]);
                $transactionStatusDTO = new TransactionStatusDTO($transactionStatus);
                $arr_statuses[$i] = $transactionStatusDTO;
            }
            
        }

        return $arr_statuses;
    }

    /**
     *
     * @param config $config
     *
     * @param String $transId Array of transaction ids or hashes
     *
     * @return TransactionSearchDTO array
     */
    public function SearchTransaction($config, $transIds, $groupType){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->searchTransaction($groupType, $transIds);
        $arr_trans = array();
        if ($data[1] == 200){ // successfull
            return $this->formatData($networkType, $data[0]);
        } else return null;
    }

    /**
     *
     * @param config $config
     *
     * @param String $transId Array of transaction ids or hashes
     *
     * @return TransactionSearchDTO array
     */
    public function SearchTransactions($config, $groupType){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->searchTransactions($groupType);
        $arr_trans = array();
        if ($data[1] == 200){ // successfull
            $arr_trans['pagination'] = new PaginationTransactionsDTO($data[0]->pagination);
            for($i=0;$i<count($data[0]->data);$i++){
                $transaction = $this->formatData($networkType, $data[0]->data[$i]);
                $arr_trans['data'][$i] = $transaction;
            }
        }
        return new TransactionSearchDTO($arr_trans);
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return TransactionInfoDTO
     */
    public function formatData($networkType, $data){
        $height = new UInt64DTO($data->meta->height);
        $hash = $data->meta->hash;
        $merkleComponentHash = $data->meta->merkleComponentHash;
        $index = $data->meta->index;
        $id = $data->meta->id;
        $transactionMetaDTO = array(
            "height" => $height,
            "hash" => $hash,
            "merkleComponentHash" => $merkleComponentHash,
            "index" => $index,
            "id" => $id
        );

        $meta = new TransactionMetaDTO($transactionMetaDTO);

        $signature = $data->transaction->signature;
        $signer = $data->transaction->signer;
        $version = $data->transaction->version;
        $type = $data->transaction->type;
        $maxFee = new UInt64DTO($data->transaction->maxFee);
        $deadline = new UInt64DTO($data->transaction->deadline);

        $transaction = array(
            'signature' => $signature,
            'signer' => $signer,
            'version' => $version,
            'type' => $type,
            'maxFee' => $maxFee,
            'deadline' => $deadline
        );
        // var_dump(dechex($type));die;
        switch (dechex($type)){
            case TransactionType::AGGREGATE_BONDED: //aggregate bonded 
                $data = $this->formatAggregate($networkType,$data->transaction->cosignatures,$data->transaction->transactions);
                $transaction["cosignatures"] = $data->cosignatures;
                $transaction["transactions"] = $data->transactions;
                $transaction = new AggregateTransactionDTO($transaction);
                break;

            case TransactionType::AGGREGATE_COMPLETED: //aggregate completed
                $data = $this->formatAggregate($networkType,$data->transaction->cosignatures,$data->transaction->transactions);
                $transaction["cosignatures"] = $data->cosignatures;
                $transaction["transactions"] = $data->transactions;
                $transaction = new AggregateTransactionDTO($transaction);
                break;

            case TransactionType::LOCK: //lock transaction
                $data = $this->formatHashLock($data->transaction->duration,$data->transaction->mosaicId,$data->transaction->amount,$data->transaction->hash);
                $transaction["duration"] = $data->duration;
                $transaction["mosaic"] = $data->mosaic;
                $transaction["hash"] = $data->hash;
                $transaction = new HashLockTransactionDTO($transaction);
                break;
                
            case TransactionType::TRANSFER: //transfer transaction
                $data = $this->formatTransfer($networkType,$data->transaction->mosaics,$data->transaction->recipient,$data->transaction->message);
                $transaction["mosaics"] = $data->mosaics;
                $transaction["recipient"] = $data->recipient;
                $transaction["message"] = $data->message;
                $transaction = new TransferTransactionDTO($transaction);
                break;

            case TransactionType::MOSAIC_DEFINITION: //mosaic definition transaction
                $data = $this->formatMosaicDefinition($data->transaction->mosaicNonce,$data->transaction->mosaicId,$data->transaction->properties);
                $transaction["mosaicNonce"] = $data->mosaicNonce;
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction["properties"] = $data->properties;
                $transaction = new MosaicDefinitionTransactionDTO($transaction);
                break;

            case TransactionType::MOSAIC_SUPPLY_CHANGE: //mosaic supply change transaction
                $data = $this->formatMosaicSupplyChange($data->transaction->mosaicId,$data->transaction->direction,$data->transaction->delta);
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction["direction"] = $data->direction;
                $transaction["delta"] = $data->delta;
                $transaction = new MosaicSupplyChangeTransactionDTO($transaction);
                break;

            case TransactionType::REGISTER_NAMESPACE: //register namespace transaction
                // TODO: ASK is parentId exist in other transactions
                $data = $this->formatRegisterNamespace($data->transaction->namespaceType,$data->transaction->duration,$data->transaction->namespaceId,$data->transaction->name,$data->transaction->parentId);
                $transaction["namespaceType"] = $data->namespaceType;
                $transaction["duration"] = $data->duration;
                $transaction["namespaceId"] = $data->namespaceId;
                $transaction["name"] = $data->name;
                $transaction["parentId"] = $data->parentId;
                $transaction = new RegisterNamespaceTransactionDTO($transaction);
                break;

            case TransactionType::ADDRESS_ALIAS: //address alias transaction
                $data = $this->formatAddressAlias($data->transaction->aliasAction,$data->transaction->namespaceId,$data->transaction->address);
                $transaction["aliasAction"] = $data->aliasAction;
                $transaction["namespaceId"] = $data->namespaceId;
                $transaction["address"] = $data->address;
                $transaction = new AddressAliasTransactionDTO($transaction);
                break;

            case TransactionType::MOSAIC_ALIAS: //mosaic alias transaction
                $data = $this->formatMosaicAlias($data->transaction->aliasAction,$data->transaction->namespaceId,$data->transaction->mosaicId);
                $transaction["aliasAction"] = $data->aliasAction;
                $transaction["namespaceId"] = $data->namespaceId;
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction = new MosaicAliasTransactionDTO($transaction);
                break;

            case TransactionType::MODIFY_MULTISIG: //modify multisig account transaction
                $data = $this->formatModifyMultisigAccount($data->transaction->minRemovalDelta,$data->transaction->minApprovalDelta,$data->transaction->modifications);
                $transaction["minRemovalDelta"] = $data->minRemovalDelta;
                $transaction["minApprovalDelta"] = $data->minApprovalDelta;
                $transaction["modifications"] = $data->modifications;
                $transaction = new ModifyMultisigAccountTransactionDTO($transaction);
                break;

            case TransactionType::ACCOUNT_PROPERTY_ADDRESS: //account property address transaction
                $data = $this->formatAccountProperty($data->transaction->propertyType,$data->transaction->modifications);
                $transaction["propertyType"] = $data->propertyType;
                $transaction["modifications"] = $data->modifications;
                $transaction = new AccountPropertiesTransactionDTO($transaction);
                break;
            
            case TransactionType::ACCOUNT_PROPERTY_MOSAIC: //account property mosaic transaction
                $data = $this->formatAccountProperty($data->transaction->propertyType,$data->transaction->modifications);
                $transaction["propertyType"] = $data->propertyType;
                $transaction["modifications"] = $data->modifications;
                $transaction = new AccountPropertiesTransactionDTO($transaction);
                break;

            case TransactionType::ACCOUNT_PROPERTY_ENTITY_TYPE: //account property antity type transaction
                $data = $this->formatAccountProperty($data->transaction->propertyType,$data->transaction->modifications);
                $transaction["propertyType"] = $data->propertyType;
                $transaction["modifications"] = $data->modifications;
                $transaction = new AccountPropertiesTransactionDTO($transaction);
                break;

            case TransactionType::SECRET_LOCK: //secret lock transaction
                $data = $this->formatSecretLock($networkType,$data->transaction->duration,$data->transaction->mosaicId,$data->transaction->amount,$data->transaction->hashAlgorithm,$data->transaction->secret,$data->transaction->recipient);
                $transaction["duration"] = $data->duration;
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction["amount"] = $data->amount;
                $transaction["hashAlgorithm"] = $data->hashAlgorithm;
                $transaction["secret"] = $data->secret;
                $transaction["recipient"] = $data->recipient;
                $transaction = new SecretLockTransactionDTO($transaction);
                break;
            
            case TransactionType::SECRET_PROOF: //secret proof transaction
                $data = $this->formatSecretProof($networkType,$data->transaction->hashAlgorithm,$data->transaction->secret,$data->transaction->proof,$data->transaction->recipient);
                $transaction["hashAlgorithm"] = $data->hashAlgorithm;
                $transaction["secret"] = $data->secret;
                $transaction["proof"] = $data->proof;
                $transaction["recipient"] = $data->recipient;
                $transaction = new SecretProofTransactionDTO($transaction);
                break;

            case TransactionType::LINK_ACCOUNT: //account link transaction
                $data = $this->formatAccountLink($data->transaction->remoteAccountKey,$data->transaction->action);
                $transaction["remoteAccountKey"] = $data->remoteAccountKey;
                $transaction["action"] = $data->action;
                $transaction = new AccountLinkTransactionDTO($transaction);
                break;
        }
        return new TransactionInfoDTO(array("meta" => $meta,"transaction" => $transaction));
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return EmbeddedTransactionInfoDTO
     */
    public function formatEmbeddedData($networkType, $data){
        $height = new UInt64DTO($data->meta->height);
        $aggregateHash = $data->meta->aggregateHash;
        $aggregateId = $data->meta->aggregateId;
        $index = $data->meta->index;
        $id = $data->meta->id;
        $transactionMetaDTO = array(
            "height" => $height,
            "aggregateHash" => $aggregateHash,
            "aggregateId" => $aggregateId,
            "index" => $index,
            "id" => $id
        );

        $meta = new EmbeddedTransactionMetaDTO($transactionMetaDTO);

        $signer = $data->transaction->signer;
        $version = $data->transaction->version;
        $type = $data->transaction->type;

        $transaction = array(
            'signer' => $signer,
            'version' => $version,
            'type' => $type
        );
        
        switch (dechex($type)){
            case TransactionType::LOCK: //lock transaction
                $data = $this->formatHashLock($data->transaction->duration,$data->transaction->mosaicId,$data->transaction->amount,$data->transaction->hash);
                $transaction["duration"] = $data->duration;
                $transaction["mosaic"] = $data->mosaic;
                $transaction["hash"] = $data->hash;
                $transaction = new EmbeddedHashLockTransactionDTO($transaction);
                break;
                
            case TransactionType::TRANSFER: //transfer transaction
                $data = $this->formatTransfer($networkType,$data->transaction->mosaics,$data->transaction->recipient,$data->transaction->message);
                $transaction["mosaics"] = $data->mosaics;
                $transaction["recipient"] = $data->recipient;
                $transaction["message"] = $data->message;
                $transaction = new EmbeddedTransferTransactionDTO($transaction);
                break;

            case TransactionType::MOSAIC_DEFINITION: //mosaic definition transaction
                $data = $this->formatMosaicDefinition($data->transaction->mosaicNonce,$data->transaction->mosaicId,$data->transaction->properties);
                $transaction["mosaicNonce"] = $data->mosaicNonce;
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction["properties"] = $data->properties;
                $transaction = new EmbeddedMosaicDefinitionTransactionDTO($transaction);
                break;

            case TransactionType::MOSAIC_SUPPLY_CHANGE: //mosaic supply change transaction
                $data = $this->formatMosaicSupplyChange($data->transaction->mosaicId,$data->transaction->direction,$data->transaction->delta);
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction["direction"] = $data->direction;
                $transaction["delta"] = $data->delta;
                $transaction = new EmbeddedMosaicSupplyChangeTransactionDTO($transaction);
                break;

            case TransactionType::REGISTER_NAMESPACE: //register namespace transaction
                $data = $this->formatRegisterNamespace($data->transaction->namespaceType,$data->transaction->duration,$data->transaction->namespaceId,$data->transaction->name,$data->transaction->parentId);
                $transaction["namespaceType"] = $data->namespaceType;
                $transaction["duration"] = $data->duration;
                $transaction["namespaceId"] = $data->namespaceId;
                $transaction["name"] = $data->name;
                $transaction["parentId"] = $data->parentId;
                $transaction = new EmbeddedRegisterNamespaceTransactionDTO($transaction);
                break;

            case TransactionType::ADDRESS_ALIAS: //address alias transaction
                $data = $this->formatAddressAlias($data->transaction->aliasAction,$data->transaction->namespaceId,$data->transaction->address);
                $transaction["aliasAction"] = $data->aliasAction;
                $transaction["namespaceId"] = $data->namespaceId;
                $transaction["address"] = $data->address;
                $transaction = new EmbeddedAddressAliasTransactionDTO($transaction);
                break;

            case TransactionType::MOSAIC_ALIAS: //mosaic alias transaction
                $data = $this->formatMosaicAlias($data->transaction->aliasAction,$data->transaction->namespaceId,$data->transaction->mosaicId);
                $transaction["aliasAction"] = $data->aliasAction;
                $transaction["namespaceId"] = $data->namespaceId;
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction = new EmbeddedMosaicAliasTransactionDTO($transaction);
                break;

            case TransactionType::MODIFY_MULTISIG: //modify multisig account transaction
                $data = $this->formatModifyMultisigAccount($data->transaction->minRemovalDelta,$data->transaction->minApprovalDelta,$data->transaction->modifications);
                $transaction["minRemovalDelta"] = $data->minRemovalDelta;
                $transaction["minApprovalDelta"] = $data->minApprovalDelta;
                $transaction["modifications"] = $data->modifications;
                $transaction = new EmbeddedModifyMultisigAccountTransactionDTO($transaction);
                break;

            case TransactionType::ACCOUNT_PROPERTY_ADDRESS: //account property address transaction
                $data = $this->formatAccountProperty($data->transaction->propertyType,$data->transaction->modifications);
                $transaction["propertyType"] = $data->propertyType;
                $transaction["modifications"] = $data->modifications;
                $transaction = new EmbeddedAccountPropertiesTransactionDTO($transaction);
                break;
            
            case TransactionType::ACCOUNT_PROPERTY_MOSAIC: //account property mosaic transaction
                $data = $this->formatAccountProperty($data->transaction->propertyType,$data->transaction->modifications);
                $transaction["propertyType"] = $data->propertyType;
                $transaction["modifications"] = $data->modifications;
                $transaction = new EmbeddedAccountPropertiesTransactionDTO($transaction);
                break;

            case TransactionType::ACCOUNT_PROPERTY_ENTITY_TYPE: //account property antity type transaction
                $data = $this->formatAccountProperty($data->transaction->propertyType,$data->transaction->modifications);
                $transaction["propertyType"] = $data->propertyType;
                $transaction["modifications"] = $data->modifications;
                $transaction = new EmbeddedAccountPropertiesTransactionDTO($transaction);
                break;

            case TransactionType::SECRET_LOCK: //secret lock transaction
                $data = $this->formatSecretLock($networkType,$data->transaction->duration,$data->transaction->mosaicId,$data->transaction->amount,$data->transaction->hashAlgorithm,$data->transaction->secret,$data->transaction->recipient);
                $transaction["duration"] = $data->duration;
                $transaction["mosaicId"] = $data->mosaicId;
                $transaction["amount"] = $data->amount;
                $transaction["hashAlgorithm"] = $data->hashAlgorithm;
                $transaction["secret"] = $data->secret;
                $transaction["recipient"] = $data->recipient;
                $transaction = new EmbeddedSecretLockTransactionDTO($transaction);
                break;
            
            case TransactionType::SECRET_PROOF: //secret proof transaction
                $data = $this->formatSecretProof($networkType,$data->transaction->hashAlgorithm,$data->transaction->secret,$data->transaction->proof,$data->transaction->recipient);
                $transaction["hashAlgorithm"] = $data->hashAlgorithm;
                $transaction["secret"] = $data->secret;
                $transaction["proof"] = $data->proof;
                $transaction["recipient"] = $data->recipient;
                $transaction = new EmbeddedSecretProofTransactionDTO($transaction);
                break;

            case TransactionType::LINK_ACCOUNT: //account link transaction
                $data = $this->formatAccountLink($data->transaction->remoteAccountKey,$data->transaction->action);
                $transaction["remoteAccountKey"] = $data->remoteAccountKey;
                $transaction["action"] = $data->action;
                $transaction = new EmbeddedAccountLinkTransactionDTO($transaction);
                break;
        }
        return new EmbeddedTransactionInfoDTO(array("meta" => $meta,"transaction" => $transaction));;
    }

    /**
     *
     * @param array $data
     * 
     * @return TransactionStatusDTO
     */
    private function formatDataStatus($data){
        $group = $data->group;
        $status = $data->status;
        $hash = $data->hash;
        $height = new UInt64DTO($data->height);
        $deadline = new UInt64DTO($data->deadline);

        $transactionStatus = array(
            'group' => $group,
            'status' => $status,
            'hash' => $hash,
            'deadline' => $deadline,
            'height' => $height
        );
        return $transactionStatus;
    }

    /**
     *
     * @param config $config
     *
     * @param String $payload
     * 
     * @return response
     */
    public function AnnounceTransaction($config, $payload){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->announceTransaction($payload);
        
        if ($data[1] == 202){ // successfull
            return $data[0]->message;
        }
        else throw new \Exception("Error");
    }

    /**
     *
     * @param config $config
     *
     * @param String $payload
     * 
     * @return response
     */
    public function AnnounceAggregateBondedTransaction($config, $payload){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->announcePartialTransaction($payload);
        
        if ($data[1] == 202){ // successfull
            return $data[0]->message;
        }
        else throw new \Exception("Error");
    }

    /**
     *
     * @param config $config
     *
     * @param String $payload
     * 
     * @return response
     */
    public function AnnounceAggregateBondedCosignatureTransaction($config, $payload){
        $TransactionRoutesApi = new TransactionRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $TransactionRoutesApi->announceCosignatureTransaction($payload);
        
        if ($data[1] == 202){ // successfull
            return $data[0]->message;
        }
        else throw new \Exception("Error");
    }

    public function formatTransfer($networkType,$mosaics_raw,$recipient_raw,$message_raw){
        $mosaics = array();
        for ($i=0;$i<count($mosaics_raw);$i++){
            $id = new UInt64DTO($mosaics_raw[$i]->id);
            $amount = new UInt64DTO($mosaics_raw[$i]->amount);
            $mosaic = new MosaicDTO($id,$amount);
            $mosaics[$i] = $mosaic;
        }

        $hex = new \Proximax\Utils\Hex;
        if (is_string($recipient_raw)){
            $addrDecode = $hex->DecodeString($recipient_raw);
            $recipient = Base32::encode(implode(array_map("chr", $addrDecode)));
        }
        else if(is_array($recipient_raw)){ //NamespaceId
            $recipient = new UInt64DTO($recipient_raw);
        }
        
        $message = new MessageDTO($message_raw->type,$message_raw->payload);

        $result = new \stdClass();
        $result->mosaics = $mosaics;
        $result->recipient = $recipient;
        $result->message = $message;
        
        return $result;
    }

    public function formatMosaicDefinition($mosaicNonce_raw,$mosaicId_raw,$properties_raw){
        $mosaicId = new UInt64DTO($mosaicId_raw);

        $properties = array();
        for ($i=0;$i<count($properties_raw);$i++){
            $id = $properties_raw[$i]->id;
            $value = new UInt64DTO($properties_raw[$i]->value);
            $mosaicPropertyDTO = array(
                "id" => $id,
                "value" => $value
            );
            $properties[$i] = new MosaicPropertyDTO($mosaicPropertyDTO);
        }
        $result = new \stdClass();
        $result->mosaicNonce = $mosaicNonce_raw;
        $result->mosaicId = $mosaicId;
        $result->properties = $properties;
        
        return $result;
    }

    public function formatMosaicSupplyChange($mosaicId,$direction,$delta){
        $mosaicId = new UInt64DTO($mosaicId);
        $delta = new UInt64DTO($delta);
        $result = new \stdClass();
        $result->mosaicId = $mosaicId;
        $result->direction = $direction;
        $result->delta = $delta;
        
        return $result;
    }

    public function formatHashLock($duration,$mosaicId,$amount,$hash){
        $id = new UInt64DTO($mosaicId);
        $amount = new UInt64DTO($amount);
        $mosaic = new MosaicDTO($id,$amount);

        $result = new \stdClass();
        $result->mosaic = $mosaic;
        $result->duration = new UInt64DTO($duration);
        $result->hash = $hash;

        return $result;
    }

    public function formatRegisterNamespace($namespaceType,$duration,$namespaceId,$name,$parentId){
        $result = new \stdClass();
        $result->namespaceType = $namespaceType;
        $result->duration = new UInt64DTO($duration);
        $result->namespaceId = new UInt64DTO($namespaceId);
        $result->name = $name;
        $result->parentId = new UInt64DTO($parentId);

        return $result;
    }

    public function formatAddressAlias($aliasAction,$namespaceId,$address){
        $result = new \stdClass();
        $result->aliasAction = $aliasAction;
        $result->namespaceId = new UInt64DTO($namespaceId);
        $result->address = $address;

        return $result;
    }

    public function formatMosaicAlias($aliasAction,$namespaceId,$mosaicId){
        $result = new \stdClass();
        $result->aliasAction = $aliasAction;
        $result->namespaceId = new UInt64DTO($namespaceId);
        $result->mosaicId = new UInt64DTO($mosaicId);

        return $result;
    }

    public function formatModifyMultisigAccount($minRemovalDelta,$minApprovalDelta,$modifications_raw){
        $modifications = array();
        for ($i=0;$i<count($modifications_raw);$i++){
            $modification = $modifications_raw[$i];
            $modifications[$i] = new CosignatoryModificationDTO($modification->type,$modification->cosignatoryPublicKey);
        }
        $result = new \stdClass();
        $result->minRemovalDelta = $minRemovalDelta;
        $result->minApprovalDelta = $minApprovalDelta;
        $result->modifications = $modifications;

        return $result;
    }

    public function formatAccountProperty($propertyType,$modifications_raw){
        $modifications = array();
        for ($i=0;$i<count($modifications_raw);$i++){
            $modification = $modifications_raw[$i];
            if (is_array($modification->value)){
                $value = new UInt64DTO($modification->value);
            }
            else if (is_string($modification->value)){
                $value = $modification->value;
            }
            else if (is_int($modification->value)){
                $value = $modification->value;
            }
            $accountPropertiesModificationDTO = array(
                "type" => $modification->type,
                "value" => $value
            );
            $modifications[$i] = new AccountPropertiesModificationDTO($accountPropertiesModificationDTO);
        }
        $result = new \stdClass();
        $result->propertyType = $propertyType;
        $result->modifications = $modifications;

        return $result;
    }

    public function formatSecretLock($networkType,$duration,$mosaicId,$amount,$hashAlgorithm,$secret,$recipient_raw){
        $hex = new \Proximax\Utils\Hex;
        if (is_string($recipient_raw)){
            $addrDecode = $hex->DecodeString($recipient_raw);
            $recipient = Base32::encode(implode(array_map("chr", $addrDecode)));
        }
        else if(is_array($recipient_raw)){ //NamespaceId
            $recipient = new UInt64DTO($recipient_raw);
        }
        $result = new \stdClass();
        $result->duration = new UInt64DTO($duration);
        $result->mosaicId = new UInt64DTO($mosaicId);
        $result->amount = new UInt64DTO($amount);
        $result->hashAlgorithm = $hashAlgorithm;
        $result->secret = $secret;
        $result->recipient = $recipient;

        return $result;
    }

    public function formatSecretProof($networkType,$hashAlgorithm,$secret,$proof,$recipient_raw){
        $hex = new \Proximax\Utils\Hex;
        if (is_string($recipient_raw)){
            $addrDecode = $hex->DecodeString($recipient_raw);
            $recipient = Base32::encode(implode(array_map("chr", $addrDecode)));
        }
        else if(is_array($recipient_raw)){ //NamespaceId
            $recipient = new UInt64DTO($recipient_raw);
        }
        $result = new \stdClass();
        $result->hashAlgorithm = $hashAlgorithm;
        $result->secret = $secret;
        $result->proof = $proof;
        $result->recipient = $recipient;

        return $result;
    }

    public function formatAccountLink($remoteAccountKey,$action){
        $result = new \stdClass();
        $result->remoteAccountKey = $remoteAccountKey;
        $result->action = $action;

        return $result;
    }

    public function formatAggregate($networkType,$cosignatures_raw,$transactions_raw){
        $cosignatures = array();
        for ($i=0;$i<count($cosignatures_raw);$i++){
            $cosignatures[$i] = new CosignatureDTO($cosignatures_raw[$i]->signature,$cosignatures_raw[$i]->signer);
        }

        $transactions = array();
        for ($i=0;$i<count($transactions_raw);$i++){
            $transactions[$i] = $this->formatEmbeddedData($networkType,$transactions_raw[$i]);
        }
        $result = new \stdClass();
        $result->cosignatures = $cosignatures;
        $result->transactions = $transactions;

        return $result;
    }
}
?>