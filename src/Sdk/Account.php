<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Sdk;
use Proximax\Core\KeyPair;
use Proximax\API\AccountRoutesApi;
use Proximax\Model\AccountDTO;
use Proximax\Model\Account as AccountModel;
use Proximax\Model\TransactionDTO;
use Proximax\ApiClient;
use Base32\Base32;
use Proximax\Infrastructure\TransactionMapping;
use Proximax\Model\MosaicDTO;
use Proximax\Model\TransactionInfo;
use Proximax\Model\Address;
use Proximax\Model\PublicAccount;
use Proximax\Model\Message;
use Proximax\Model\HeightDTO;
use Proximax\Model\MultisigDTO;
use Proximax\Model\UInt64DTO;
use Proximax\Model\AccountPropertyDTO;
use Proximax\Model\AccountPropertiesDTO;
use Proximax\Model\AccountPropertiesInfoDTO;
use Proximax\Model\AccountNamesDTO;
/**
 * Account class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Account{

    public $KeyPair;

    public function __construct($KeyPair = null){
        if (!$KeyPair){
            $this->KeyPair = new KeyPair;
        }
        else $this->KeyPair = $KeyPair;
    }
    
    /**
     * Sign message
     *
     * @param  Transaction $tx
     *
     * @return SignedTransaction
     */
    public function Sign($tx){
        return signTransactionWith($tx, $this);
    }

    /**
     *
     * @param config $config
     *
     * @param Address $accountId Account address or publicKey
     * 
     * @return AccountDTO
     */
    public function GetAccountInfo($config, $accountId){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $AccountRoutesApi->getAccountInfo($accountId);
        if ($data[1] == 200){ // successfull
            $account = $this->formatDataAccount($networkType, $data[0]);
        }
        else $account = null;
        return new AccountDTO($account);
    }

    /**
     *
     * @param config $config
     *
     * @param array $accountIds Array of publicKeys and address
     * 
     * @return AccountDTO array
     */
    public function GetAccountsInfo($config, $addresses){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;

        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $AccountRoutesApi->getAccountsInfo($addresses);
        $arr_account = array();
        if ($data[1] == 200){ // successfull
            for ($i=0;$i<count($data[0]);$i++){
                $account = $this->formatDataAccount($networkType, $data[0][$i]);
                $AccountDTO = new AccountDTO($account);
                $arr_account[$i] = $AccountDTO;
            }
        }
        return $arr_account;
    }

    /**
     *
     * @param config $config
     *
     * @param String $publicKey
     * 
     * @return TransactionDTO
     */
    public function Transactions($config, $publicKey, $option = null){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        if ($option != null){
            $data = $AccountRoutesApi->transactions($publicKey, $option->pageSize, $option->id);
        }
        else $data = $AccountRoutesApi->transactions($publicKey);
        $arr_transaction = array();
        if ($data[1] == 200){
            for ($i=0;$i<count($data[0]->data);$i++){
                $transaction = (new Transaction)->formatData($networkType, $data[0]->data[$i]);
                $arr_transaction[$i] = $transaction;
            }
        }
        return $arr_transaction;
    }

    /**
     *
     * @param config $config
     *
     * @param String $publicKey
     * 
     * @return TransactionDTO
     */
    public function IncomingTransactions($config, $publicKey, $option = null){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        if ($option != null){
            $data = $AccountRoutesApi->incomingTransactions($publicKey, $option->pageSize, $option->id);
        }
        else $data = $AccountRoutesApi->incomingTransactions($publicKey);
        $arr_transaction = array();
        if ($data[1] == 200){ // successfull
            for ($i=0;$i<count($data[0]->data);$i++){
                $transaction = (new Transaction)->formatData($networkType, $data[0]->data[$i]);
                $arr_transaction[$i] = $transaction;
            }
            
        }
        return $arr_transaction;
    }

    /**
     *
     * @param config $config
     *
     * @param String $publicKey
     * 
     * @return TransactionDTO
     */
    public function OutgoingTransactions($config, $publicKey, $option = null){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        if ($option != null){
            $data = $AccountRoutesApi->outgoingTransactions($publicKey, $option->pageSize, $option->id);
        }
        else $data = $AccountRoutesApi->outgoingTransactions($publicKey);
        $arr_transaction = array();
        if ($data[1] == 200){ // successfull
            for ($i=0;$i<count($data[0]->data);$i++){
                $transaction = (new Transaction)->formatData($networkType, $data[0]->data[$i]);
                $arr_transaction[$i] = $transaction;
            }
            
        }
        return $arr_transaction;
    }


    /**
     *
     * @param config $config
     *
     * @param String $publicKey
     * 
     * @return TransactionDTO
     */
    public function UnconfirmedTransactions($config, $publicKey, $option = null){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        if ($option != null){
            $data = $AccountRoutesApi->unconfirmedTransactions($publicKey, $option->pageSize, $option->id);
        }
        else $data = $AccountRoutesApi->unconfirmedTransactions($publicKey);
        $arr_transaction = array();
        if ($data[1] == 200){ // successfull
            for ($i=0;$i<count($data[0]->data);$i++){
                $transaction = (new Transaction)->formatData($networkType, $data[0]->data[$i]);
                $arr_transaction[$i] = $transaction;
            }
            
        }
        return $arr_transaction;
    }

    /**
     *
     * @param config $config
     *
     * @param String $publicKey
     * 
     * @return MultisigDTO
     */
    public function GetAccountMultisig($config,$publicKey){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $AccountRoutesApi->getAccountMultisig($publicKey);
        if ($data[1] == 200){ // successfull
            $account = $this->formatDataMultisig($networkType, $data[0]);
        }
        else $account = null;

        return new MultisigDTO($account);
    }

    /**
     *
     * @param config $config
     *
     * @param Address $accountId Account address or publicKey
     * 
     * @return AccountPropertiesInfoDTO
     */
    public function GetAccountPropertiesInfo($config, $accountId){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $AccountRoutesApi->getAccountProperties($accountId);
        if ($data[1] == 200){ // successfull
            $account = $this->formatDataAccountProperties($networkType, $data[0]);
        }
        else $account = null;
        return new AccountPropertiesInfoDTO($account);
    }

    /**
     *
     * @param config $config
     *
     * @param Address $accountId Account address or publicKey
     *
     * @return AccountPropertiesInfoDTO
     */
    public function GetAccountNames($config, $accountId){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $AccountRoutesApi->getAccountsNames($accountId);
        $names=[];
        if ($data[1] == 200){ // successfull
            for ($i = 0; $i< count($data[0]); $i++) {
                $names[$i] = $this->formatDataAccountNames($networkType, $data[0][$i]);
            }
            // $account = $this->formatDataAccountProperties($networkType, $data[0]);
        }
        else $names = null;
        return $names;
    }

    /**
     *
     * @param config $config
     *
     * @param array $accountIds Array of publicKeys and address
     * 
     * @return AccountPropertiesInfoDTO array
     */
    public function GetAccountsPropertiesInfo($config, $addresses){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;

        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $AccountRoutesApi->getAccountsPropertiesInfo($addresses);
        $arr_account = array();
        if ($data[1] == 200){ // successfull
            for ($i=0;$i<count($data[0]);$i++){
                $account = $this->formatDataAccountProperties($networkType, $data[0][$i]);
                $AccountDTO = new AccountPropertiesInfoDTO($account);
                $arr_account[$i] = $AccountDTO;
            }
        }
        return $arr_account;
    }


    /**
     *
     * @param config $config
     *
     * @param String $publicKey
     *
     * @return MultisigDTO
     */
    public function GetAccountMultisigGraph($config,$publicKey){
        $AccountRoutesApi = new AccountRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $AccountRoutesApi->getAccountMultisigGraph($publicKey);
        if ($data[1] == 200){ // successfull
            var_dump($data[0]); die;
            // $account = $this->formatDataMultisig($networkType, $data[0]);
        }
        else $account = null;

        return new MultisigDTO($account);
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return AccountDTO array
     */
    private function formatDataAccount($networkType, $data){
        $hex = new \Proximax\Utils\Hex;
        $add = $hex->DecodeString($data->account->address);
        
        $addr = Base32::encode(implode(array_map("chr", $add)));
        $address = new Address($addr,$networkType);
        $addressHeight = new HeightDTO($data->account->addressHeight);

        $publicKey = $data->account->publicKey;
        $publicKeyHeight = new HeightDTO($data->account->publicKeyHeight);

        $mosaics_raw = $data->account->mosaics;
        $mosaics = array();
        for ($i=0;$i<count($mosaics_raw);$i++){
            $mosaic = new MosaicDTO($mosaics_raw[$i]->id,$mosaics_raw[$i]->amount);
            $mosaics[$i] = $mosaic;
        }

        $accountType = $data->account->accountType;
        $linkedAccountKey = $data->account->linkedAccountKey;

        $account = array(
            "address" => $address,
            "addressHeight" => $addressHeight,
            "publicKey" => $publicKey,
            "publicKeyHeight" => $publicKeyHeight,
            "mosaics" => $mosaics,
            "accountType" => $accountType,
            "linkedAccountKey" => $linkedAccountKey
        );
        return $account;
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return AccountDTO array
     */
    private function formatDataMultisig($networkType, $data){
        $account = (new AccountModel)->newAccountFromPublicKey($data->multisig->account,$networkType);
        $accountAddress = $account->getAddress();
        $minApproval = $data->multisig->minApproval;
        $minRemoval = $data->multisig->minRemoval;
        $cosignatories = array();
        $multisigAccounts = array();
        for ($i=0;$i<count($data->multisig->cosignatories);$i++){
            $cosignatories[$i] = (new AccountModel)->newAccountFromPublicKey($data->multisig->cosignatories[$i],$networkType);
        }
        for ($i=0;$i<count($data->multisig->multisigAccounts);$i++){
            $multisigAccounts[$i] = (new AccountModel)->newAccountFromPublicKey($data->multisig->multisigAccounts[$i],$networkType);
        }
        $multisig = array(
            "account" => $account,
            "accountAddress" => $accountAddress,
            "minApproval" => $minApproval,
            "minRemoval" => $minRemoval,
            "cosignatories" => $cosignatories,
            "multisigAccounts" => $multisigAccounts,
        );
        return $multisig;
    }


    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return AccountPropertiesInfoDTO array
     */
    private function formatDataAccountProperties($networkType, $data){
        $hex = new \Proximax\Utils\Hex;
        $address = $hex->DecodeString($data->accountProperties->address);
        $address = Base32::encode(implode(array_map("chr", $address)));

        $properties = array();
        for ($i=0;$i<count($data->accountProperties->properties);$i++){
            $property = $data->accountProperties->properties[$i];
            $propertyType = $property->propertyType;
            $values = array();
            for ($j=0;$j<count($property->values);$j++){
                if ($propertyType == 1 || $propertyType == 129){
                    $hex = new \Proximax\Utils\Hex;
                    $value = $hex->DecodeString($property->values[$i]);
                    $value = Base32::encode(implode(array_map("chr", $value)));
                }
                else if (is_string($property->values[$i]) || is_int($property->values[$i])){
                    $value = $property->values[$i];
                }
                else if (is_array($property->values[$i])){
                    $value = new UInt64DTO($property->values[$i]);
                }
                $values[$i] = $value;
            }
            $accountPropertyDTO = array(
                "propertyType" => $propertyType,
                "values" => $values
            );
            $properties[$i] = new AccountPropertyDTO($accountPropertyDTO);       
        }

        $accountPropertiesDTO = array(
            "address" => $address,
            "properties" => $properties
        );

        $accountProperties = new AccountPropertiesDTO($accountPropertiesDTO);
        $account = array(
            "accountProperties" => $accountProperties
        );
        return $account;
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     *
     * @return AccountNamesDTO array
     */
    private function formatDataAccountNames($networkType, $data){
        $names = [];
        for ($i=0;$i<count($data->names);$i++){
            $names[$i] = (new AccountModel)->newAccountFromPublicKey($data->multisig->cosignatories[$i],$networkType);
        }

        $acountNames = array(
            "address" => $data->address,
            "names" => $names
        );
        return new AccountNamesDTO($acountNames);
    }
}
?>