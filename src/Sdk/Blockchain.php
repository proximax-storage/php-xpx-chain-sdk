<?php
/**
 * NIS2 API
 *
 * This document defines all the nis2 api routes and behaviour
 *
 * OpenAPI spec version: 1.0.0
 * Contact: greg@evias.be
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 * 
 */

namespace Proximax\Sdk;
use Proximax\API\BlockchainRoutesApi;
use Proximax\ApiClient;
use Proximax\Model\HeightDTO;
use Proximax\Infrastructure\TransactionMapping;
use Proximax\Model\Account;
use Proximax\Model\BlockInfoDTO;
use Proximax\Model\BlockchainStorageInfo;
use Proximax\Model\StatementsDTO;
use Proximax\Model\UInt64DTO;
use Proximax\Model\SourceDTO;
use Proximax\Model\BalanceTransferReceiptDTO;
use Proximax\Model\BalanceChangeReceiptDTO;
use Proximax\Model\ArtifactExpiryReceiptDTO;
use Proximax\Model\InflationReceiptDTO;
use Proximax\Model\TransactionStatementDTO;
use Proximax\Model\ResolutionEntryDTO;
use Proximax\Model\MerklePathItem;
use Proximax\Model\MerkleProofInfo;
use Proximax\Model\MerkleProofInfoDTO;
use Proximax\Model\BlockchainServerDTO;
/**
 * Blockchain class Doc Comment
 *
 * @category class
 * @package  Proximax
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Blockchain{
    /**
     *
     * @param config $config
     * 
     * @return HeightDTO
     */
    public function GetBlockchainHeight($config){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getBlockchainHeight();
        if ($data[1] == 200){ // successfull
            return new HeightDTO($data[0]->height);
        }
        else return new HeightDTO;

        
    }


    /**
     *
     * @param config $config
     *
     * @param int $height
     * 
     * @return BlockInfoDTO array
     */
    public function GetBlockByHeight($config, $height){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;

        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;
        $data = $BlockchainRoutesApi->getBlockByHeight($height);

        if ($data[1] == 200){ // successfull
            $blockInfo = $this->formatDataBlock($networkType,$data[0]);
            return new BlockInfoDTO($blockInfo);
        }
        else return new BlockInfoDTO;
    }

    /**
     *
     * @param config $config
     *
     * @param int $height
     *
     * @return BlockInfoDTO array
     */
    public function GetBlockReceipts($config, $height){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;

        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;
        $data = $BlockchainRoutesApi->getBlockReceipts($height);

        if ($data[1] == 200){ // successfull
            $blockInfo = $this->StatementsDTO($networkType,$data[0]);
            return new StatementsDTO($blockInfo);
        }
        else return new StatementsDTO;
    }

        /**
     *
     * @param config $config
     *
     * @param int $height
     * 
     * @return BlockInfoDTO array
     */
    public function GetBlockByHeightWithLimit($config, $height, $limit){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;

        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;
        $data = $BlockchainRoutesApi->getBlocksByHeightWithLimit($height,$limit);

        $blockInfo_array = array();
        if ($data[1] == 200){ // successfull
            for($i=0;$i<count($data[0]);$i++){
                $blockInfo = $this->formatDataBlock($networkType,$data[0][$i]);
                $blockInfo_array[$i] = new BlockInfoDTO($blockInfo);
            }
            return $blockInfo_array;
        }
        else return $blockInfo_array;
    }

    /**
     *
     * @param config $config
     * 
     * @param int $height
     * 
     * @return HeightDTO
     */
    public function GetBlockTransactions($config,$height){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getBlockTransactions($height);
        $transactions = array();
        if ($data[1] == 200){ // successfull
            for($i=0;$i<count($data[0]->data);$i++){
                $transactions[$i] = (new Transaction)->formatData($networkType,$data[0]->data[$i]);
            }
            return $transactions;
        }
        else return null;
    }

    /**
     *
     * @param config $config
     * 
     * @return  int
     */
    public function GetBlockchainScore($config){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getBlockchainScore();
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return (new TransactionMapping)->ExtractCurrentScore($data[0]);
        }
        else return null;
    }

    /**
     *
     * @param config $config
     * 
     * @return BlockchainStorageInfo
     */
    public function GetBlockchainStorage($config){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getDiagnosticStorage();
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return new BlockchainStorageInfo($data[0]->numBlocks,$data[0]->numTransactions,$data[0]->numAccounts);
        }
        else return null;
    }

    /**
     *
     * @param config $config
     * 
     * @return StatementsDTO
     */
    public function GetReceiptsByHeight($config,$height){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getReceiptsByHeight($height);
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return new StatementsDTO($this->StatementsDTO($networkType,$data[0]));
        }
        else return null;
    }

    /**
     *
     * @param config $config
     * 
     * @return MerkleProofInfoDTO
     */
    public function GetMerkleReceiptByHeightAndHash($config,$height,$hash){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getMerkleReceiptByHeightAndHash($height,$hash);
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return new MerkleProofInfoDTO($this->MerkleProofInfoDTO($networkType,$data[0]));
        }
        else return null;
    }

    /**
     *
     * @param config $config
     * 
     * @return MerkleProofInfoDTO
     */
    public function GetMerkleTransactionByHeightAndHash($config,$height,$hash){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getMerkleTransactionByHeightAndHash($height,$hash);
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return new MerkleProofInfoDTO($this->MerkleProofInfoDTO($networkType,$data[0]));
        }
        else return null;
    }

    /**
     *
     * @param config $config
     *
     * @return BlockchainStorageInfo
     */
    public function GetServerInfo($config){
        $BlockchainRoutesApi = new BlockchainRoutesApi;
        $ApiClient = new ApiClient;
        $url = $config->BaseURL;
        $ApiClient->setHost($url);
        $networkType = $config->NetworkType;

        $data = $BlockchainRoutesApi->getServerInfo();
        $transactions = array();
        if ($data[1] == 200){ // successfull
            return new BlockchainServerDTO($data[0]);
        }
        else return null;
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return BlockInfoDTO array
     */
    private function formatDataBlock($networkType, $data){
        $TransactionMapping = new TransactionMapping;
        $hash = $data->meta->hash;
        $generationHash = $data->meta->generationHash;
        $totalFee = $TransactionMapping->ExtractMaxFee($data->meta->totalFee);
        $numTransactions = $data->meta->numTransactions;

        $signature = $data->block->signature;
        $signer = (new Account)->newAccountFromPublicKey($data->block->signer,$networkType);
        $version = $TransactionMapping->ExtractVersion($data->block->version);
        $type = $data->block->type;
        $height = new HeightDTO($data->block->height);
        $timestamp = $TransactionMapping->ExtractDeadline($data->block->timestamp);
        $difficulty = $TransactionMapping->ExtractDifficulty($data->block->difficulty);
        $feeMultiplier = $data->block->feeMultiplier;
        $previousBlockHash = $data->block->previousBlockHash;
        $blockTransactionsHash = $data->block->blockTransactionsHash;
        $blockReceiptsHash = $data->block->blockReceiptsHash;
        $stateHash = $data->block->stateHash;
        $beneficiary = $data->block->beneficiary;

        $blockInfo = array(
            'hash' => $hash,
            'generationHash' => $generationHash,
            'totalFee' => $totalFee,
            'numTransactions' => $numTransactions,
            'signature' => $signature,
            'signer' => $signer,
            'version' => $version,
            'type' => $type,
            'height' => $height,
            'timestamp' => $timestamp,
            'difficulty' => $difficulty,
            'feeMultiplier' => $feeMultiplier,
            'previousBlockHash' => $previousBlockHash,
            'blockTransactionsHash' => $blockTransactionsHash,
            'blockReceiptsHash' => $blockReceiptsHash,
            'stateHash' => $stateHash,
            'beneficiary' => $beneficiary
        );
        return $blockInfo;
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return StatementsDTO 
     */
    private function StatementsDTO($networkType, $data){
        $transactionStatements = array();
        for ($i=0;$i<count($data->transactionStatements);$i++){
            $transactionStatement = $data->transactionStatements[$i];
            $height = new UInt64DTO($transactionStatement->height);
            $sourceDTO = array(
                "primaryId" => $transactionStatement->source->primaryId,
                "secondaryId" => $transactionStatement->source->secondaryId
            );
            $source = new SourceDTO($sourceDTO);
            $receipts = array();
            for ($j=0;$j<count($transactionStatement->receipts);$j++){
                $receipt = $transactionStatement->receipts[$j];
                if (dechex($receipt->type)[0] == "1"){ //recheck
                    $sender = $receipt->sender;
                    $recipient = $receipt->recipient;
                    $mosaicId = $receipt->mosaicId;
                    $amount = $receipt->amount;
                    $version = $receipt->version;
                    $type = $receipt->type;
                    $receiptDTO = array(
                        "sender" => $sender,
                        "recipient" => $recipient,
                        "mosaicId" => $mosaicId,
                        "amount" => $amount,
                        "version" => $version,
                        "type" => $type,
                    );
                    $receipts[$j] = new BalanceTransferReceiptDTO($receiptDTO);
                }
                else if (dechex($receipt->type)[0] == "2" || dechex($receipt->type)[0] == "3"){
                    $account = $receipt->account;
                    $mosaicId = $receipt->mosaicId;
                    $amount = $receipt->amount;
                    $version = $receipt->version;
                    $type = $receipt->type;
                    $receiptDTO = array(
                        "account" => $account,
                        "mosaicId" => $mosaicId,
                        "amount" => $amount,
                        "version" => $version,
                        "type" => $type,
                    );
                    $receipts[$j] = new BalanceChangeReceiptDTO($receiptDTO);
                }
                else if (dechex($receipt->type)[0] == "4"){
                    $artifactId = $receipt->artifactId;
                    $version = $receipt->version;
                    $type = $receipt->type;
                    $receiptDTO = array(
                        "artifactId" => $artifactId,
                        "version" => $version,
                        "type" => $type,
                    );
                    $receipts[$j] = new ArtifactExpiryReceiptDTO($receiptDTO);
                }
                else if (dechex($receipt->type)[0] == "5"){
                    $mosaicId = $receipt->mosaicId;
                    $amount = $receipt->amount;
                    $version = $receipt->version;
                    $type = $receipt->type;
                    $receiptDTO = array(
                        "mosaicId" => $mosaicId,
                        "amount" => $amount,
                        "version" => $version,
                        "type" => $type,
                    );
                    $receipts[$j] = new InflationReceiptDTO($receiptDTO);
                }
            }
            $transactionStatementDTO = array(
                "height" => $height,
                "source" => $source,
                "receipts" => $receipts
            );
            $transactionStatements[$i] = new TransactionStatementDTO($transactionStatementDTO);
        }
        $addressResolutionStatements = array();
        for ($i=0;$i<count($data->addressResolutionStatements);$i++){
            $addressResolutionStatement = $data->addressResolutionStatements[$i];
            $height = $addressResolutionStatement->height;
            $unresolved = $addressResolutionStatement->unresolved;
            $resolutionEntries = array();
            for ($j=0;$j<count($addressResolutionStatement->resolutionEntries);$j++){
                $resolutionEntry = $addressResolutionStatement->resolutionEntries[$j];
                $source = $resolutionEntry->source;
                $resolved = $resolutionEntry->resolved;
                $resolutionEntryDTO = array(
                    "source" => $source,
                    "resolved" => $resolved
                );
                $resolutionEntries[$j] = new ResolutionEntryDTO($resolutionEntryDTO);
            }
            $resolutionStatementDTO = array(
                "height" => $height,
                "unresolved" => $unresolved,
                "resolutionEntries" => $resolutionEntries
            );
            $addressResolutionStatements = new ResolutionStatementDTO($resolutionStatementDTO);
        }
        $mosaicResolutionStatements = array();
        return $statementsDTO = array(
            "transactionStatements" => $transactionStatements,
            "addressResolutionStatements" => $addressResolutionStatements,
            "mosaicResolutionStatements" => $mosaicResolutionStatements
        );
    }

    /**
     * @param int $networkType
     *
     * @param array $data
     * 
     * @return array
     */
    private function MerkleProofInfoDTO($networkType, $data){
        $merklePath = array();
        for ($i=0;$i<count($data->payload->merklePath);$i++){
            $position = $data->payload->merklePath[$i]->position;
            $hash = $data->payload->merklePath[$i]->hash;
            $merklePath[$i] = new MerklePathItem($position, $hash);
        }
        $payload = new MerkleProofInfo($merklePath);
        $type = $data->type;
        return $merkleProofInfoDTO = array(
            "payload" => $payload,
            "type" => $type
        );
    }
}
?>